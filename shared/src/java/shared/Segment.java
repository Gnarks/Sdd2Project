package shared;

import java.util.ArrayList;
import java.util.List;

public class Segment {
  private Point start;
  private Point end;
  private String color;
  /**
   * The line generated by the segment
   * Depends on start and end points
   * line[0] = line's slope
   * line[1] = line's intercept
   */
  private double[] line;
  private boolean isVertical;
  

  public Segment(Point start,Point end,String color){
    if (start.x <= end.x){
      this.start = start;
      this.end = end;
    } else {
      this.start = end;
      this.end = start;}
    this.color = color;
    this.isVertical = false;
    updateLine(); 
  }

  public Segment(double x1, double y1, double x2, double y2, String color){
    Point _start = new Point(x1,y1);
    Point _end = new Point(x2,y2);
    if (_start.x < _end.x){
      this.start = _start;
      this.end = _end;
    } else {
      this.start = _end;
      this.end = _start;}
    this.color = color;
    updateLine();
  }

  public Point getStart(){
    return this.start;
  }
  public Point getEnd(){
    return this.end;
  }
  public String getColor(){
    return this.color;
  }

  public double[] getLine(){
    return this.line;
  }

  public boolean isVertical(){
    return this.isVertical;
  }

  public void setStart(Point start){
    this.start = start;
    updateLine();
  }

  public void setEnd(Point end){
    this.end = end;
    updateLine();
  }

  public void setColor(String color){
    this.color = color;
  }

  private void updateLine(){
    double m;
    double p;
    if (this.start.x == this.end.x){
      this.isVertical = true;
      m = this.end.x;
      p = 0;
    }
    else{
      m = (this.end.y - this.start.y)/(this.end.x-this.start.x);
      p = this.start.y - (m*this.start.x);}
    this.line = new double[]{m,p};
  }
 /**
  * Function to define if a point is in h-, h+ or belongs to the segment's line
  *@param Point we need to analyse
  *@return -1 if the point belongs to h-
            1 if the point belongs to h+
            0 if the point belongs to the segment's line
  */
  public int locationPoint(Point point){

    if(isVertical){
      if(Utils.areEqual(point.x, this.line[0])){
        return 0;
      } else if(point.x > this.line[0]){
        return 1;
      } else {
      return -1;
      }
    }
    if(this.line[0] == 0){
      if(Utils.areEqual(point.y, this.line[1])){
        return 0;
      } else if(point.y < this.line[1]){
        return 1;
      } else {
        return -1;
      }
    }
    double x = (point.y - this.line[1])/this.line[0];
    if (Utils.areEqual(point.x,x)){
      return 0;
    } else if (point.x < x){
      return -1;
    } else {
      return 1;
    }
  }
  
  /**
   * Function to define the intersection between the segment's line and another
   *@param Segment the segment to define the intersection with 
   */
  public Point interSeg(Segment seg){
    if ((isVertical && seg.isVertical()) || (!(isVertical || seg.isVertical())&&Utils.areEqual(seg.getLine()[0],this.line[0]))){
      return null;
    }
    if (this.isVertical){
      double x = this.line[0];
      return new Point(x,seg.getLine()[0]*x+seg.getLine()[1]);
    }
    if(seg.isVertical){
      double x = seg.getLine()[0];
      return new Point(x,this.line[0]*x+this.line[1]);
    }
    double x = (seg.getLine()[1] - this.line[1])/(this.line[0]-seg.getLine()[0]);
    double y = this.line[0]*x + this.line[1];
    return new Point(x,y);
  }
  
  /**
   * returns if the point is on the segment 
 * @param point the point to check
 * @return if the point p is on the segement
   */
  public boolean onSeg(Point point){
    if (point == null)
      return false;

    if(this.isVertical)
      return (Utils.areEqual(point.x, this.line[0])) && Math.min(start.y,end.y) <= point.y && point.y <= Math.max(start.y,end.y); 
    
    return Utils.areEqual(point.y, this.line[0]*point.x + this.line[1]) && (start.x <= point.x && point.x <= end.x);
  }

  /**
   * align :  the segments that are aligned with the current segment
   * d_minus : the segments that are on the d- part of the segment
   * d_plus : the segments that are on the d+ part of the segment
   */
  public ArrayList<ArrayList<Segment>> generateNode(ArrayList<Segment> data){
    ArrayList<Segment> align = new ArrayList<>();
    align.add(this);
    ArrayList<Segment> d_minus = new ArrayList<>();
    ArrayList<Segment> d_plus = new ArrayList<>();

    data.forEach(seg-> {
      Point inter = this.interSeg(seg); 
      int locationStart= this.locationPoint(seg.getStart());
      int locationEnd = this.locationPoint(seg.getEnd());
      if (locationStart == locationEnd || locationStart == 0 || locationEnd == 0){
        switch (locationStart) {
          case -1:
            d_minus.add(seg);
            break;
          case 1:
            d_plus.add(seg);
            break;
          default:
            if (locationEnd == 0){
            align.add(seg);
            }
            else if (locationEnd == 1){
              d_plus.add(seg);
            }
            else{
              d_minus.add(seg);
            }
            break;
        }
      }
      else{
      Segment startSeg = new Segment(seg.getStart(),inter,seg.getColor());
      Segment endSeg = new Segment(inter,seg.getEnd(),seg.getColor());

      if (locationStart == -1){ d_minus.add(startSeg);} else { d_plus.add(startSeg);}
      if (locationEnd == -1){ d_minus.add(endSeg);} else { d_plus.add(endSeg);}
     }
    });
    return new ArrayList<>(List.of(align,d_minus,d_plus));
  }

  public String toString(){
    return "Start: "+ start + " | End: "+ end + " | Color: " + color;
  }
}
