package shared;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;
import java.lang.Math;

public class Segment {
  private Point start;
  private Point end;
  private Color color;
  /**
   * The line generated by the segment
   * Depends on start and end points
   * line[0] = line's slope
   * line[1] = line's intercept
   */
  private double[] line;
  
  public Segment(Point start,Point end,Color color){
    this.start = start;
    this.end = end;
    this.color = color;
    updateLine(); 
  }

  public Segment(double x1, double y1, double x2, double y2, Color color){
    this.start = new Point(x1,y1);
    this.end = new Point(x2,y2);
    this.color = color;
    updateLine();
  }

  public Point getStart(){
    return this.start;
  }
  public Point getEnd(){
    return this.end;
  }
  public Color getColor(){
    return this.color;
  }

  public double[] getLine(){
    return this.line;
  }

  public void setStart(Point start){
    this.start = start;
    updateLine();
  }

  public void setEnd(Point end){
    this.end = end;
    updateLine();
  }

  public void setColor(Color color){
    this.color = color;
  }

  private void updateLine(){
    double m = (this.end.y - this.start.y)/(this.end.x-this.start.x);
    double p = this.start.y - (m*this.start.x);
    this.line = new double[]{m,p};
  }
 /**
  * Function to define if a point is in h-, h+ or belongs to the segment's line
  *@param Point we need to analyse
  *@return -1 if the point belongs to h-
            1 if the point belongs to h+
            0 if the point belongs to the segment's line
  */
  public int locationPoint(Point point){
    if(this.line[0] == 0){
      if(point.y > this.line[1]){
        return -1;
      }
      if(point.y < this.line[1]){
        return 1;
      } else {
        return 0;
      }
    }
    double x = (point.y - this.line[1])/this.line[0];
    if (point.x < x){
      return -1;
    } else if (areEqual(point.x,x)){
      return 0;
    } else {
      return 1;
    }
  }
  
  /**
   * Function to define the intersection between the segment's line and another
   *@param Segment the segment to define the intersection with 
   */
  public Point interSeg(Segment seg){
    if(seg.getLine()[0]==this.line[0]){
      return null;
    }
    double x = (seg.getLine()[1] - this.line[1])/(this.line[0]-seg.getLine()[0]);
    double y = this.line[0]*x + this.line[1];
    return new Point(x,y);
  }
  /**
   * align :  the segments that are aligned with the current segment
   * d_minus : the segments that are on the d- part of the segment
   * d_plus : the segments that are on the d+ part of the segment
   */
  public ArrayList<ArrayList<Segment>> locationSegment(ArrayList<Segment> data){
    ArrayList<Segment> align = new ArrayList<>();
    ArrayList<Segment> d_minus = new ArrayList<>();
    ArrayList<Segment> d_plus = new ArrayList<>();

    data.forEach(seg-> {
      Point inter = this.interSeg(seg); 
      int locationStart= this.locationPoint(seg.getStart());
      int locationEnd = this.locationPoint(seg.getEnd());

      if (locationStart == locationEnd){
        switch (locationStart) {
          case -1:
            d_minus.add(seg);
            break;
          case 1:
            d_plus.add(seg);
            break;
          default:
            align.add(seg);
            break;
        }
      }
      else{
      Segment startSeg = new Segment(seg.getStart(),inter,seg.getColor());
      Segment endSeg = new Segment(inter,seg.getEnd(),seg.getColor());

      if(!areEqual(seg.getStart() ,inter)){
        if (locationStart == -1){ d_minus.add(startSeg);} else { d_plus.add(startSeg);}
      }
      if(!areEqual(seg.getEnd() ,inter)){}
        if (locationEnd == -1){ d_minus.add(endSeg);} else { d_plus.add(endSeg);}
     }
    });
    return new ArrayList<>(List.of(align,d_minus,d_plus));
  }
  /**
   * Define if 2 values are equals with a biais
   */
  public boolean areEqual(double x1, double x2){
    return Math.abs(x1 - x2) < 1E-14;
  }
  
  /**
   * Define if 2 points are equals with a biais
   */
  public boolean areEqual(Point p1, Point p2){
    return Math.abs(p1.x - p2.x) < 1E-14 && Math.abs(p1.y - p2.y) < 1E-14;
  }

  public String toString(){
    return "Start: "+ start + " | End: "+ end + " | Color: " + color.toString();
  }
}
